
 
                        port_pin_set_output_level(LED_0_PIN, LED_0_ACTIVE);
 
                        port_pin_set_output_level(LED_0_PIN, !LED_0_ACTIVE);
 


port_pin_toggle_output_level(LED0_PIN);

tc_get_config_defaults(&config_tc);

if (!port_pin_get_input_level(BUTTON_0_PIN));



//说明1： io口在任何复位之后，默认配置是“高阻输入模式”。

//说明2： 关于配置P2.0为输入脚
            。当配置RPD  (CONFIG0.2)  为0，P2.0被配置为输入引脚。同时P2.0将永远在输入模式和施密特触发模式，
               通过P20UP（P2S.7)使能内部上拉电阻。
            。如果RPD未编程，P2.0作为外部复位引脚，P2.0作为管脚功能无效，由于作为复位脚，内部上拉电阻始终有效，
               此种状态下读取P2.0的值始终为0.

//注意： gpio口不能设置内部上拉和下拉， 但准双向模式自带弱上拉， P20做输入时有上拉



=================D21 可直接操作的寄存器===========================


#define     REG_PORT_DIR0              (0x41004400U) /**< \brief (PORT) Data Direction 0 */
#define     REG_PORT_DIRCLR0           (0x41004404U) /**< \brief (PORT) Data Direction Clear 0 */
#define     REG_PORT_DIRSET0           (0x41004408U) /**< \brief (PORT) Data Direction Set 0 */
#define     REG_PORT_DIRTGL0           (0x4100440CU) /**< \brief (PORT) Data Direction Toggle 0 */
#define     REG_PORT_OUT0              (0x41004410U) /**< \brief (PORT) Data Output Value 0 */
#define     REG_PORT_OUTCLR0           (0x41004414U) /**< \brief (PORT) Data Output Value Clear 0 */
#define     REG_PORT_OUTSET0           (0x41004418U) /**< \brief (PORT) Data Output Value Set 0 */
#define     REG_PORT_OUTTGL0           (0x4100441CU) /**< \brief (PORT) Data Output Value Toggle 0 */
#define     REG_PORT_IN0               (0x41004420U) /**< \brief (PORT) Data Input Value 0 */
#define     REG_PORT_CTRL0             (0x41004424U) /**< \brief (PORT) Control 0 */
#define     REG_PORT_WRCONFIG0         (0x41004428U) /**< \brief (PORT) Write Configuration 0 */
#define     REG_PORT_PMUX0             (0x41004430U) /**< \brief (PORT) Peripheral Multiplexing 0 */
#define     REG_PORT_PINCFG0           (0x41004440U) /**< \brief (PORT) Pin Configuration 0 */

#define     REG_PORT_DIR1              (0x41004480U) /**< \brief (PORT) Data Direction 1 */
#define     REG_PORT_DIRCLR1           (0x41004484U) /**< \brief (PORT) Data Direction Clear 1 */
#define     REG_PORT_DIRSET1           (0x41004488U) /**< \brief (PORT) Data Direction Set 1 */
#define     REG_PORT_DIRTGL1           (0x4100448CU) /**< \brief (PORT) Data Direction Toggle 1 */
#define     REG_PORT_OUT1              (0x41004490U) /**< \brief (PORT) Data Output Value 1 */
#define     REG_PORT_OUTCLR1           (0x41004494U) /**< \brief (PORT) Data Output Value Clear 1 */
#define     REG_PORT_OUTSET1           (0x41004498U) /**< \brief (PORT) Data Output Value Set 1 */
#define     REG_PORT_OUTTGL1           (0x4100449CU) /**< \brief (PORT) Data Output Value Toggle 1 */
#define     REG_PORT_IN1               (0x410044A0U) /**< \brief (PORT) Data Input Value 1 */
#define     REG_PORT_CTRL1             (0x410044A4U) /**< \brief (PORT) Control 1 */
#define     REG_PORT_WRCONFIG1         (0x410044A8U) /**< \brief (PORT) Write Configuration 1 */
#define     REG_PORT_PMUX1             (0x410044B0U) /**< \brief (PORT) Peripheral Multiplexing 1 */
#define     REG_PORT_PINCFG1           (0x410044C0U) /**< \brief (PORT) Pin Configuration 1 */



===================1. 设置gpio口模式=====================


//1. 设置gpio口模式：  （输入输出）

   PxM1.n    PxM2.n    I/O 类型    （P0,P1的所有端口默认值为10 -- 输入）
   0             0             准双向
   0             1             推挽输出
   1             0             输入 (高阻)      //--默认值
   1             1             开漏 

   如设置P0.0为准双向，则 P0M1.0 =0, P0M2.0=0


//1. gpio库函数操作：

   #define SET_BIT0               0x01
   #define P00_Quasi_Mode      P0M1&=~SET_BIT0;   P0M2&=~SET_BIT0

    Set_All_GPIO_Quasi_Mode    //设置所有引脚为准双向

    P00_Quasi_Mode                 //设置P00为准双向  
    P00_PushPull_Mode             //P00为推挽输出
    P00_Input_Mode                 //P00为输入
    P00_OpenDrain_Mode         //P00为开漏


1. gpio的寄存器操作：

   .设置PB09为输出，高电平：               
	struct port_config  pinconf;
	port_get_config_defaults(&pinconf);
	pinconf.direction  = PORT_PIN_DIR_OUTPUT;
	port_pin_set_config(PIN_PB09, &pinconf);
	port_pin_set_output_level(PIN_PB09, 1);	


   .翻转PB09电平：               

	 port_pin_toggle_output_level(PIN_PB09);
	 delay_s(1);



   //.设置p00为准双向：
   P0M1&=~(1<<0);   P0M2&=~(1<<0); 

   //.设置p00为推挽输出：
   P0M1&=~(1<<0);   P0M2|=(1<<0); 

   //.设置p00为输入（高阻）：
   P0M1|=(1<<0);   P0M2|=(1<<0); 

   //.设置p00为开漏：
   P0M1|=(1<<0);   P0M2&=~(1<<0); 


//1. gpio的功能设置：

    pwm功能： 
       PWM3_P00_OUTPUT_ENABLE    //PIOCON0|=0x08， 设置P00为pwm3的输出引脚                                                 



===================2. 设置gpio高低电平=====================


//2. 设置gpio口高低电平的库函数操作  （无意义，不考虑）


//2. 设置gpio'口高低电平的寄存器操作

   P00=1    //P0.0 置高电平
   P00=0    //P0.0 置低电平

   P0 = 0x00;   //P0口全部置低电平
   P0 = 0xff;    //P0口全部置高电平


//===================3. 设置gpio 电平翻转=====================


//3.  翻转电平

    P16=~P16;



//====================4. 读取gpio高低电平==========================

    P15_Quasi_Mode;          //设置P15为准双向    （带弱上拉）
    //P15_Input_Mode                 //P15为输入

        //读取P15电平
        if(!P15)  //SW3
            printf("\n SW3 low \r\n"); 
        else
            printf("\n SW3 high \r\n"); 


  P04_Quasi_Mode 
  if（P04 ==0)
      P01=1;



//====================5. 设置gpio速度==========================


set_P1SR_3       //设置P13为快速模式   （如用于I2C引脚SCL时，要求速度很快）

P1SR |= (1<<3);





//=====================6. gpio口的宏定义考虑====================================

//define io

#define PWM2_OUT_PIN                  P05                       //pwm2 pin
#define PWM2_PUSHPULL_MODE            P05_PushPull_Mode
#define PWM2_OUTPUT_ENABLE            PWM2_P05_OUTPUT_ENABLE

#define CHARGE_LED_PIN                P16                       //charge led pin
#define CHARGE_LED_PUSHPULL_MODE      P16_PushPull_Mode

#define CHARGE_DONE_PIN               P17                       //charge done
//#define CHARGE_DONE_INPUT_MODE        P17_Input_Mode             
#define CHARGE_DONE_QUASI_MODE        P17_Quasi_Mode             

#define POWER_KEY_PIN                 P15                       //power key
#define POWER_KEY_INPUT_MODE          P15_Input_Mode

#define BACK_LED_PIN                  P12                       //back led
#define BACK_LED_PUSHPULL_MODE        P12_PushPull_Mode

#define AMP_CTRL_PIN                  P11                       //amp control
#define AMP_CTRL_PUSHPULL_MODE        P11_PushPull_Mode

#define BT_ONOFF_PIN                  P10                       //BT onoff
#define BT_ONOFF_PUSHPULL_MODE        P10_PushPull_Mode

#define USB_DET_PIN                   P00                       //usb detect
#define USB_DET_INPUT_MODE            P00_Input_Mode

#define PAIRING_LED_PIN               P01                       //pairing led
#define PAIRING_LED_PUSHPULL_MODE     P01_PushPull_Mode

#define PAIR_DET_PIN                  P02                       //pair detect
#define PAIR_DET_INPUT_MODE           P02_Input_Mode

#define MAIN_POWER_PIN                P03                       //main power
#define MAIN_POWER_PUSHPULL_MODE      P03_PushPull_Mode




//=====================其他，高级宏定义====================================


#define LED_BLUE_PORT    1    
#define LED_BLUE_PIN     2   

---


#define P12_PushPull_Mode         P1M1&=~SET_BIT2;   P1M2|=SET_BIT2
#define Pxy_PushPull_Mode         PxM1&=~SET_BITy;   PxM2|=SET_BITy


#define  setpushpull(x,y)      P##x##M1&=~SET_BIT##y;   P##x##M2|=SET_BIT##y


---

#define P12_Input_Mode            P1M1|=SET_BIT2;P1M2&=~SET_BIT2

#define  setinput(x,y)      P##x##M1|=SET_BIT##y;   P##x##M2&=~SET_BIT##y

---

#define P12_OpenDrain_Mode      P1M1|=SET_BIT2;P1M2|=SET_BIT2

#define  setopendrain(x,y)      P##x##M1|=SET_BIT##y;   P##x##M2|=SET_BIT##y

---

#define P12_Quasi_Mode            P1M1&=~SET_BIT2;P1M2&=~SET_BIT2

#define  setquasi(x,y)      P##x##M1&=~SET_BIT##y;   P##x##M2&=~SET_BIT##y







